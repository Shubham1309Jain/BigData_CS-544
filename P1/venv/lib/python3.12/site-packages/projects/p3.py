import os.path
import subprocess
import time
import random
from lib.autobadger import Callback, Autobadger, AutobadgerCallback
from lib.enums import Project, Registry
from lib.exceptions import MissingRequiredResource
from lib.io import IOTargetWrapper, DockerBuildTargetWrapper, DockerComposeTargetWrapper
from lib.registry import register, graded
from lib.runnable import TestRunnable
from lib.types import TestError


@register(project=Project.P3, registry=Registry.TEST, points=75)
class ProjectThreeTest(TestRunnable):
    def __init__(self, callback: "AutobadgerCallback", delegate: "Autobadger"):
        super().__init__(callback, delegate)
        self.complex_col_sums = dict()

    def build_complex(self):
        num_rows = 100
        columns = ["a", "b", "c", "d"]
        for col in columns:
            self.complex_col_sums[col] = 0

        with open(IOTargetWrapper(f"./inputs/complex.csv"), "w") as f:
            f.write(",".join(columns) + "\n")
            for _ in range(num_rows):
                values = []
                for col in columns:
                    num = random.randint(0, 100)
                    self.complex_col_sums[col] += num
                    values.append(str(num))
                f.write(",".join(values) + "\n")

    @staticmethod
    def build_docker(dockerfile, image) -> int | TestError:
        if not os.path.exists(IOTargetWrapper(dockerfile)):
            return TestError(
                message=f"{dockerfile} does not exist.",
                earned=0,
            )
        try:
            output = subprocess.run(
                DockerBuildTargetWrapper(t=image, f=dockerfile),
                capture_output=True,
                timeout=60 * 5,
            )
        except subprocess.TimeoutExpired:
            return TestError(message="`docker build` time out.", earned=0)
        if output.returncode != 0:
            return TestError(
                message=f"Failed to build docker image: {output.stderr}",
                earned=0,
            )
        return 5

    @graded(Q=1, points=5)
    def test_server_docker_build(self) -> int | TestError:
        return self.build_docker("Dockerfile", f"{self.delegate.grade_id}")

    def run_container(self) -> int | TestError:
        image = self.delegate.grade_id
        try:
            path = os.path.abspath(str(IOTargetWrapper("./inputs")))
            output = subprocess.run(
                f"docker run --name {image} -d -m 512m -v {path}:/inputs {image}".split(),
                capture_output=True,
                timeout=60 * 5,
            )
        except subprocess.TimeoutExpired:
            return TestError(message="`docker run` timed out.", earned=0)
        if output.returncode == 0 or output.returncode == 125:
            if output.returncode == 125:
                print(
                    f"NOTE: container '{image}' is already running... "
                    f"this may lead to different results and cause your tests to fail. "
                    f"You may want to teardown your container and try again."
                )
            return 5
        return TestError(
            message=f"`docker run` failed with exit status {output.returncode}",
            earned=0,
        )

    def if_container_running(self) -> bool | TestError:
        image = self.delegate.grade_id
        try:
            output = subprocess.run(
                f"docker ps --filter name={image} --format {{{{.Names}}}}".split(),
                capture_output=True,
                text=True,
            )
            running_containers = output.stdout.strip().splitlines()
            if image in running_containers:
                return True
            else:
                return False
        except subprocess.CalledProcessError as e:
            return TestError(
                message=f"Error checking the container status: {e.stderr}", earned=0
            )

    @graded(Q=2, points=5)
    def test_server_docker_run(self) -> int | TestError:
        run_ret = self.run_container()
        if isinstance(run_ret, TestError):
            return run_ret
        for _ in range(5):
            test_ret = self.if_container_running()
            if isinstance(test_ret, TestError):
                return test_ret
            if not test_ret:
                time.sleep(2)
                continue
            return 5

        return TestError(message="Did not find running test container", earned=0)

    def individual_upload(self, csv_file) -> tuple[bool, str]:
        if self.delegate.verbose:
            print(f"Uploading {csv_file}")
        upload_output = subprocess.check_output(
            [
                "docker",
                "exec",
                f"{self.delegate.grade_id}",
                "python3",
                "upload.py",
                csv_file,
            ]
        )
        upload_output = upload_output.decode("utf-8")
        if "success" not in upload_output:
            return False, upload_output
        return True, upload_output

    @graded(Q=3, points=10)
    def test_upload(self) -> int | TestError:
        self.build_complex()
        test_ret = self.if_container_running()
        if test_ret != True:
            return TestError(message="Did not find running test container", earned=0)
        time.sleep(5)
        container_simple_csv_path = "/inputs/simple.csv"
        container_complex_csv_path = "/inputs/complex.csv"
        done, msg = self.individual_upload(container_simple_csv_path)
        if not done:
            return TestError(
                message=f"Error uploading {container_simple_csv_path}: {msg}", earned=0
            )
        done, msg = self.individual_upload(container_complex_csv_path)
        if not done:
            return TestError(
                message=f"Error uploading {container_complex_csv_path}: {msg}", earned=5
            )
        done, msg = self.individual_upload(container_complex_csv_path)
        if not done:
            return TestError(
                message=f"Error uploading {container_complex_csv_path} the second time: {msg}",
                earned=5,
            )
        return 10

    def individual_sum(
        self, format: str, column: str, expected: int
    ) -> tuple[bool, str]:
        sum_output = subprocess.check_output(
            ["docker", "exec", f"{self.delegate.grade_id}", "python3", format, column]
        )
        sum_output = sum_output.decode("utf-8")
        result = sum_output.strip().split("\n")[-1]
        try:
            result = int(result)
        except ValueError as e:
            return False, f"Expecting integer for sum output: {str(e)}"
        if result != expected:
            return (
                False,
                f"Expecting output {expected} for column {column}, got {result}",
            )
        return True, sum_output

    @graded(Q=4, points=10)
    def test_csvsum(self) -> int | TestError:
        col = "w"
        done, msg = self.individual_sum("csvsum.py", col, 0)
        if not done:
            return TestError(message=f"Error summing csv files: {msg}", earned=0)

        col = "x"
        done, msg = self.individual_sum("csvsum.py", col, 5)
        if not done:
            return TestError(message=f"Error summing csv files: {msg}", earned=0)

        col = "c"
        done, msg = self.individual_sum(
            "csvsum.py", col, 2 * self.complex_col_sums.get(col, 0)
        )
        if not done:
            return TestError(message=f"Error summing csv files: {msg}", earned=5)
        return 10

    @graded(Q=5, points=10)
    def test_parquetsum(self) -> int | TestError:
        col = "w"
        done, msg = self.individual_sum("parquetsum.py", col, 0)
        if not done:
            return TestError(message=f"Error summing parquet files: {msg}", earned=0)

        col = "y"
        done, msg = self.individual_sum("parquetsum.py", col, 7)
        if not done:
            return TestError(message=f"Error summing parquet files: {msg}", earned=0)

        col = "d"
        done, msg = self.individual_sum(
            "parquetsum.py", col, 2 * self.complex_col_sums.get(col, 0)
        )
        if not done:
            return TestError(message=f"Error summing parquet files: {msg}", earned=5)
        return 10

    @graded(Q=6, points=15)
    def test_upload_bigdata(self) -> int | TestError:
        if self.delegate.verbose:
            print("Testing big-data upload. May take a while...")
        upload_output = subprocess.check_output(
            [
                "docker",
                "exec",
                f"{self.delegate.grade_id}",
                "python3",
                "bigdata.py",
            ]
        )
        upload_output = upload_output.decode("utf-8")
        if "uploaded" not in upload_output:
            return TestError(
                message=f"bigdata.py failed with output: {upload_output}", earned=0
            )
        return 15

    @graded(Q=7, points=20)
    def test_sum_bigdata(self) -> int | TestError:
        col = "z"
        true_sum = 19999950000009

        csv_done, csv_msg = self.individual_sum("csvsum.py", col, true_sum)
        parquet_done, parquet_msg = self.individual_sum("parquetsum.py", col, true_sum)
        if not csv_done or not parquet_done:
            earned = 20
            message = ""
            if not csv_done:
                earned -= 10
                message += f"Error summing csv files: {csv_msg}\n"
            if not parquet_done:
                earned -= 10
                message += f"Error summing parquet files: {parquet_msg}\n"
            return TestError(message=message, earned=earned)

        csv_time_ms = float(csv_msg.strip().split("\n")[-2].split()[0])
        parquet_time_ms = float(parquet_msg.strip().split("\n")[-2].split()[0])
        if self.delegate.verbose:
            print(csv_time_ms, parquet_time_ms)
            time_ratio = csv_time_ms / parquet_time_ms
            if time_ratio < 2:
                print("🟡 Warning: Parquet sum should be significantly faster.")
                print(
                    "It may be due to reading the whole parquet file rather than a single column."
                )
                print("Ignore the warning if you have avoided that.")
        return 20


@register(project=Project.P3, registry=Registry.CALLBACK)
class ProjectThreeCallback(Callback):
    def on_teardown(self):
        subprocess.run(
            f"docker rm -f {self.delegate.grade_id}".split(),
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )

    def on_setup(self):
        self.on_teardown()

    def on_validate_required_resources(self):
        required = [
            IOTargetWrapper("Dockerfile"),
            IOTargetWrapper("server.py"),
            IOTargetWrapper("upload.py"),
            IOTargetWrapper("csvsum.py"),
            IOTargetWrapper("parquetsum.py"),
        ]
        for file in required:
            if not os.path.exists(file):
                raise MissingRequiredResource(required)

    def on_before_test(self):
        pass

    def on_after_test(self):
        pass
