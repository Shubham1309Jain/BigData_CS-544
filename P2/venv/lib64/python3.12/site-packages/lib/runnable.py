import abc
import traceback
from typing import TypeVar

from typing_extensions import Generic
from typing import TYPE_CHECKING

from .exceptions import MisconfiguredTestClass, TestFailedToExecute

if TYPE_CHECKING:
    from .autobadger import AutobadgerCallback, Autobadger
from .types import AutobadgerResult, TestResult

T = TypeVar("T")


class Runnable(abc.ABC, Generic[T]):
    @abc.abstractmethod
    def run(self) -> T:
        pass


class TestRunnable(Runnable[AutobadgerResult]):
    def __init__(self, callback: "AutobadgerCallback", delegate: "Autobadger") -> None:
        super(TestRunnable, self).__init__()
        self.callback = callback
        self.delegate = delegate

    def _get_test_method_names_of(self):
        return [fn_name for fn_name in dir(self) if fn_name.startswith("test_")]

    def run(self):
        total_possible_score = self.__class__.__points__
        grade = AutobadgerResult(project=self.__class__.__project__)
        test_fns = self._get_test_method_names_of()
        if len(test_fns) < 1:
            raise MisconfiguredTestClass(class_name=self.__class__.__name__)

        # run in assigned Q number order indicated by decorators
        test_fns.sort(key=lambda fn: getattr(getattr(self, fn), "Q", 0))

        for test_fn in test_fns:
            if self.delegate.verbose:
                print(f"test '{test_fn}' running...")
            self.callback.on_before_test()
            try:
                test_result: TestResult = getattr(self, test_fn)()
            except TestFailedToExecute as e:
                trace = "\n".join(
                    [
                        f"Failed to run Q{e.Q} ('{test_fn}'):",
                        traceback.format_exc(),
                    ]
                )
                test_result = TestResult.Zero(
                    question=test_fn,
                    total=e.total,
                    message=str(e.original_exception),
                    stack_trace=trace,
                    Q=e.Q,
                )
            self.callback.on_after_test()
            if self.delegate.verbose:
                print(test_result, "\n")
            grade.add_test(test_result)
        assert (
            grade.score.total == total_possible_score
        ), f"Double check the scores of your tests and the total score for the class. {total_possible_score} != {grade.score.total}"
        return grade


RegisteredTestClass = type[Runnable[TestResult]]
