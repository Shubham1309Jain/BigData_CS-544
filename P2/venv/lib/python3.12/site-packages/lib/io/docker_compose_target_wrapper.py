import os
from typing import Optional
from .docker_target_wrapper import DockerTargetWrapper


class DockerComposeTargetWrapper(DockerTargetWrapper):
    """
    Use when needing to run a docker compose command.
    Abstracts away the target directory of the grader.
    Note when using with subprocess.run():
        - Don't use shell=True
        - Don't use text=True
    """

    _instance: Optional["DockerComposeTargetWrapper"] = None
    # target directory. Should only be used when storing a grading key in the project's root dir
    target: str
    # The subcommand to run (i.e. "up" or "kill")
    subcommand: str
    command_args: dict

    @classmethod
    def seed_target(cls, target: str):
        cls.__new__(cls, command_args=None, subcommand=None, target=target)

    def __new__(
        cls,
        target: str | None = None,
        subcommand: str | None = None,
        **command_args,
    ):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.target = target if target is not None else "."
        if command_args is not None:
            cls._instance.command_args = command_args
        if subcommand is not None:
            cls._instance.subcommand = subcommand
        return cls._instance

    def __str__(self) -> str:
        """
        Returns a string representation of the docker compose command
        i.e. docker compose -f TARGET subcommand [OPTIONS]
        :return:
        """
        filename = (
            self.command_args.pop("f")
            if "f" in self.command_args
            else "docker-compose.yml"
        )
        command = (
            f"docker compose -f {os.path.join(self.target, filename)} {self.subcommand}"
        )
        for flag, value in self.command_args.items():
            flag_char = "-" if len(flag) == 1 else "--"
            command += f" {flag_char}{flag} {value}"
        return command.strip()
