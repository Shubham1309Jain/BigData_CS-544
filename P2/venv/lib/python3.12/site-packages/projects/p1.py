import os.path
import subprocess

from lib.autobadger import Callback
from lib.enums import Project, Registry
from lib.exceptions import MissingRequiredResource
from lib.io import IOTargetWrapper, DockerBuildTargetWrapper
from lib.registry import register, graded
from lib.runnable import TestRunnable
from lib.types import TestError


@register(project=Project.P1, registry=Registry.TEST, points=100)
class ProjectOneTest(TestRunnable):
    @graded(Q=1, points=10)
    def test_docker_version(self) -> int | TestError:
        docker_file = IOTargetWrapper("docker.txt")
        if not os.path.exists(docker_file):
            return TestError(
                message="docker.txt does not exist.",
                earned=0,
            )
        with open(docker_file) as f:
            version = "27.5.1"
            if version in f.read():
                return 10
        return TestError(
            message=f"Incorrect docker version found. Expected '{version}'. We recommend installing this "
            f"version for the semester.",
            earned=5,
        )

    @graded(Q=2, points=10)
    def test_compose_version(self) -> int | TestError:
        compose = IOTargetWrapper("compose.txt")
        if not os.path.exists(compose):
            return TestError(
                message="compose.txt does not exist.",
                earned=0,
            )
        with open(compose) as f:
            version = "2.32.4"
            if version in f.read():
                return 10
        return TestError(
            message=f"Incorrect docker compose version found. Expected '{version}'. We recommend installing this "
            f"version for the semester.",
            earned=5,
        )

    @graded(Q=3, points=10)
    def test_download_sh_contents(self) -> int | TestError:
        messages = []
        earned = 10
        with open(IOTargetWrapper("download.sh")) as f:
            content = f.read()
            root = "https://pages.cs.wisc.edu/~harter/cs544/data"
            for url in [
                os.path.join(root, "wi2021.csv.gz"),
                os.path.join(root, "wi2022.csv.gz"),
                os.path.join(root, "wi2023.csv.gz"),
            ]:
                if url not in content:
                    earned -= 2
                    messages.append(f"URL not found in download.sh: '{url}'")
            valid_shebangs = ["#!/usr/bin/bash", "#!/bin/bash", "#!/usr/local/bin/bash"]
            if not any(shebang in content for shebang in valid_shebangs):
                earned -= 4
                messages.append("download.sh does not have a shebang")
            earned = max(earned, 0)
        if earned == 10:
            return earned
        return TestError(message="\n".join(messages), earned=earned)

    @graded(Q=4, points=15)
    def test_multi_sh_contents(self) -> int | TestError:
        messages = []
        earned = 15
        with open(IOTargetWrapper("multi.sh")) as f:
            content = f.read()
            valid_shebangs = ["#!/usr/bin/bash", "#!/bin/bash", "#!/usr/local/bin/bash"]
            if not any(shebang in content for shebang in valid_shebangs):
                earned -= 5
                messages.append("multi.sh does not have a shebang")
            if "download.sh" not in content:
                earned -= 5
                messages.append("multi.sh does not call download.sh")
        if earned == 15:
            return earned
        return TestError(message="\n".join(messages), earned=earned)

    @graded(Q=5, points=5)
    def test_download_sh_permissions(self) -> int | TestError:
        if not os.access(IOTargetWrapper("download.sh"), os.X_OK):
            return TestError(
                message="download.sh should be executable by all users. "
                "Hint: this may cause issues with your docker build and run...",
                earned=0,
            )
        return 5

    @graded(Q=6, points=5)
    def test_multi_sh_permissions(self) -> int | TestError:
        if not os.access(IOTargetWrapper("multi.sh"), os.X_OK):
            return TestError(
                message="multi.sh should be executable by all users. "
                "Hint: this may cause issues with your docker build and run...",
                earned=0,
            )
        return 5

    @graded(Q=7, points=15)
    def test_dockerfile_contents(self) -> int | TestError:
        messages = []
        earned = 15
        dockerfile = IOTargetWrapper("Dockerfile")
        if not os.path.exists(dockerfile):
            return TestError(
                message="Dockerfile does not exist.",
                earned=0,
            )
        with open(dockerfile) as f:
            content = f.read()
            if "FROM ubuntu" not in content:
                earned -= 3
                messages.append("Dockerfile does not use ubuntu")
            if "multi.sh" not in content:
                earned -= 10
                messages.append("Dockerfile does not call multi.sh")
        if earned == 15:
            return earned
        return TestError(message="\n".join(messages), earned=earned)

    @graded(Q=8, points=15)
    def test_docker_build(self) -> int | TestError:
        if not os.path.exists(IOTargetWrapper("Dockerfile")):
            return TestError(
                message="Dockerfile does not exist.",
                earned=0,
            )
        try:
            output = subprocess.run(
                DockerBuildTargetWrapper(t=self.delegate.grade_id),
                capture_output=True,
                timeout=60 * 5,
            )
        except subprocess.TimeoutExpired:
            return TestError(message="`docker build` timed out.", earned=0)
        if output.returncode != 0:
            return TestError(
                message=f"Failed to build docker image: {output.stderr}", earned=0
            )
        return 15

    @graded(Q=9, points=15)
    def test_docker_run(self) -> int | TestError:
        if not os.path.exists(IOTargetWrapper("Dockerfile")):
            return TestError(
                message="Dockerfile does not exist.",
                earned=0,
            )
        try:
            output = subprocess.run(
                f"docker run {self.delegate.grade_id}",
                shell=True,
                capture_output=True,
                text=True,
                timeout=60 * 5,
            )
        except subprocess.TimeoutExpired:
            return TestError(message="`docker run` timed out.", earned=0)
        if output.returncode != 0:
            return TestError(
                message=f"Failed to build docker image: {output.stderr}", earned=0
            )
        elif "6729" not in output.stdout:
            return TestError(
                message=f"Incorrect count from `docker run`. Received '{output.stdout}'.",
                earned=5,
            )
        return 15


@register(project=Project.P1, registry=Registry.CALLBACK)
class ProjectOneCallback(Callback):
    def on_setup(self):
        subprocess.run(
            f"docker rmi -f {self.delegate.grade_id}",
            shell=True,
            stderr=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL,
        )
        subprocess.run(
            f"docker container rm {self.delegate.grade_id}",
            shell=True,
            stderr=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL,
        )

    def on_teardown(self):
        subprocess.run(
            f"docker rmi -f {self.delegate.grade_id}",
            shell=True,
            stderr=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL,
        )
        subprocess.run(
            f"docker container rm {self.delegate.grade_id}",
            shell=True,
            stderr=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL,
        )

    def on_validate_required_resources(self):
        """
        :throws MissingRequiredResource:
        :return:
        """
        required = [IOTargetWrapper("multi.sh"), IOTargetWrapper("download.sh")]
        for file in required:
            if not os.path.exists(file):
                raise MissingRequiredResource(required)

    def on_before_test(self):
        pass

    def on_after_test(self):
        pass
